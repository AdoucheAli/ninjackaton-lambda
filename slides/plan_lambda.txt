Plan Présentation Java 8 / Lambda

Qui utilise Java 5?
Qui utilse Java 6?
Qui utilise Java 7?
Qui a déjà utilisé Java 8?
Savez-vous quand Java 6 ne sera plus maintenu? -> Février 2013!

Qu'y a-t-il eu de nouveau dans Java 7?

Quelques APIs: nio2, quelques ajouts dans concurrency, JDBC 4.1...
Mais au quotidien, qu'est-ce qui a changé?

Project coin:
   Diamond: List<String> list = new ArrayList<>();
   Strings in switch
   Better literals: 0b11000011, 1_000_000
   Multicatch:
       try {
           ...
       }
       catch (SQLException | IOException e) {
           log(e);
       }
   Try with resources:
       try (InputStream in = new FileInputStream(inputFile);
            OutputStream out = new FileOutputSTream(outputFile)) {
            ...   
        }
        // automatically closed!
        
Rien de révolutionnaire donc.

Est-ce que vous savez quand sort Java 8? --> 2013/09/09, developer preview le 2013/02/21

Et quelles sont les principales nouveautés de Java 8?

 - Jigsaw? Non : remis à une date ultérieure
 - new Date and Time API: il était temps. Date et Calendar sont parmi les plus mal conçues des classes utilisées tous les jours par les développeurs. Mais la nouvelle API sera très proche de JODA Time. Stephen Colebourne est le spec lead. Donc finalement, rien de révolutionnaire pour ceux qui utilisent déjà joda time.
 - Lambda (idée: faire un gros slide avec la lettre grecque en minuscule): c'est le plus gros changement, sans doute plus important encore que l'introduction des génériques
 
Lambda : Java n'est plus seulement un langage OO. Il devient aussi un langage fonctionnel.

Exemple Java:
  List<Integer> list = Arrays.asList(1, 2, 3);
  List<String> transformed = new ArrayList<>();
  for (Integer i : list) {
      transformed.add(String.valueOf(i * 1000);
  }
  System.out.println(transformed);
  
Exemple JavaScript avec jsFiddle:
  HTML : <div id="test"></div>
  JS :
  var array = [1, 2, 3];
  var transformed = $.map(array, function(value) {
      return (value * 1000) + " ";
  }
  $('#test').html(array);

Exemple de code fonctionnel avec Guava : 

  List<Integer> list = Arrays.asList(1, 2, 3);
  List<String> transformed = FluentIterable.from(list)
                                           .transform(new Function<Integer, String>() {
                                               @Override
                                               public String apply(Integer input) {
                                                   return String.valueOf(input * 1000);
                                               })
                                           .toList();
  System.out.println(transformed);
  
C'est assez lourd. On perd du temps à écrire la classe anonyme, il y a une instanciation de classe à chaque fois, le code est peu lisible, et finalement, les seules parties intéressantes sont l'appel à transform(), et l'appel à String.valueOf(). Le reste, c'est du boilerplate.
  
Voilà le même appel, avec les lambda

Exemple Lambda :

  List<Integer> list = Arrays.asList(1, 2, 3);
  List<String> transformed = list.stream()
                                 .map(input -> String.valueOf(input * 1000))
                                 .collect(Collectors.<String>toList());
  System.out.println(transformed);
  
Mais finalement, quel est l'intérêt par rapport à une simple boucle for?
Supposons qu'on ait une liste de personnes, et qu'on veuille ne garder dans cette liste que les hommes, qu'on veuille ensuite les trier par ordre alphabétique
des noms et prénoms, et ne conserver que les 2 premiers.

Java 7 :

    private static void extractWithJava7() {
        List<Person> males = new ArrayList<>();
        for (Person person : Person.NINJA_SQUAD) {
            if (person.getGender() == Person.Gender.MALE) {
                males.add(person);
            }
        }
        Collections.sort(males, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                int result = o1.getLastName().compareTo(o2.getLastName());
                if (result == 0) {
                    result = o1.getFirstName().compareTo(o2.getFirstName());
                }
                return result;
            }
        });
        List<Person> result = males.subList(0, 2);
        System.out.println("result = " + result);
    }
    
Java 8 :
    
    private static void extractWithJava8() {
        List<Person> result = 
            Person.NINJA_SQUAD.stream()
                  .filter(p -> p.getGender() == Person.Gender.MALE)
                  .sorted(Comparators.<Person, String>comparing(Person::getLastName)
                                     .thenComparing(Person::getFirstName))
                  .substream(0, 2)
                  .collect(Collectors.<String>toList());
        System.out.println("result = " + result);
    }
    
Comment tout ça fonctionne-t-il?

Chaque fois qu'on a une interface avec une seule méthode abstraite, on peut en créer une instance avec une lambda.
Exemple: FileFilter, Runnable, Callable, ActionListener, Comparator, etc.

    File[] textFiles = directory.listFiles(f -> f.getName().endsWith(".txt"));
    
On appelle ces interfaces des "Functional interfaces".
Mais, les interfaces n'ont que des méthodes abstraites, non?

Plus maintenant!

  - les interfaces peuvent avoir des méthodes statiques
  - les interfaces peuvent avoir des méthodes concrètes (default)
  
  Exemple: Collection
    /**
     * Adds all the elements from the specified stream to this collection.
     *
     * @param stream source of elements to be added to this collection
     */
    @Override
    default void addAll(Stream<? extends E> stream) {
        stream.sequential().forEach(this::add);
    }
    
C'est ce qui permet d'avoir une méthode stream() dans toutes les collections (même la vôtre), une méthode addAll() dans toutes les collections (même la vôtre). Backward compatibility!

Les méthodes default ne peuvent pas être final, donc on peut toujours les redéfinir.

Quelle est la syntaxe d'une lambda? Plusieurs versions:

    Interface fonctionnelle:                               Lambda correspondante :
    interface Concatenator {
        String concat(int a, double b);                    (int a, double b) -> {
    }                                                          String s = a + " " + b; 
                                                               return s;
                                                           }
                                                           
                                                           OU
                                                           
                                                           (int a, double b) -> return a + " " + b;
                                                           
                                                           OU
                                                           
                                                           (int a, double b) -> a + " " + b;
                                                           
                                                           OU, si le compilateur peut inférer le type des arguments:
                                                           
                                                           (a, b) -> a + " " + b;
                                                           
    interface UnaryOperator {                             (a) -> a * a;
        int op(a);
    }                                                      OU
    
                                                           a -> a * a; (parenthèses optionnelles)
                                                           
    interface Supplier {                                   () -> 25;
        int get();
    }
    
Les lambdas peuvent aussi être écrites sous forme de références à des méthodes:

    interface StringToIntFunction {                        String::length qui veut dire la même chose que s -> s.length()
        int toInt(String s);
    }                                                      Integer::parseInt qui veut dire la même chose que s -> Integer.parseInt(s)
    
                                                           Integer::new qui veut dire la même chose que s -> new Integer(s)
    
                                                           stringToIntMap::get  qui veut dire la même chose que s -> stringToIntMap.get(s)
                                                           
Comme les classes anonymes, les lambda peuvent capturer des variables locales "effectively" final.
"Effectively final" : pas besoin du mot-clé final, mais on  ne peut pas assigner une autre valeur à la variable.

Exemple:
    public static List<Integer> incrementAllWith(List<Integer> list, int increment) {
        return list.stream().map(i -> i + increment).boxed().collect(Collectors.<Integer>toList());
    }

Exemple de code interdit:
  int cumulatedAge = 0; 
  persons.forEach(p -> {
      cumulatedAge += p.getAge();
  });
  
  Remplacer par 
  
  int cumulatedAge = persons.stream().map(Person::getAge).sum();
    
Qu'est-ce que c'est que ces méthodes sum() et cette méthode boxed()? 
En plus des Stream<T>, qui manipulent des objets, il y a aussi des streams pour les types primitifs: IntStream, et plus tard, LongStream, DoubleStream, etc.

Vous n'êtes pas convaincu? Vous n'aimez pas cette approche fonctionnelle? Les Streams ne permettent pas que ça. Il y a en fait deux types de pipelines différents: les pipelines séquentiels (utilisés par les streams retournés par Collection.stream()), et les pipelines parallèles (retournés par Collection.parallelStream()).

Transformation de l'un vers l'autre: stream.parallel(), stream.sequential(). L'interface est la même! Les stream parallèles utilisent le framework fork/join pour fonctionner. Evidemment, les fonctions, prédicats, destinations, etc. passés en argument des streams parallèles doivent être thread-safe. Mais c'est souvent le cas, parce que les fonctions sont la plupart du temps stateless: ils prennent une ou plusieurs valeurs en entrée, et les transforment en une valeur en sortie.

Exemple classique: map/reduce. On a 1_000_000 de tweets dans lesquels trouver le nombre max de retweets. Le stream parallèle divise le travail en plusieurs morceaux, effectue les opérations sur chaque morceux en parallèle, puis collecte les résultats.

    public static int maxRetweets(Set<Tweet> tweets) {
        return tweets.parallelStream().map(t -> t.getRetweetCount())
                                      .reduce(0, Math::max);
    }
    
Comment ça marche?

Supposons qu'on ait la classe suivante:

public class DecompilationTest {
    public static void main(String[] args) {
        Function<Integer, String> function = i -> i.toString();
        System.out.println("function.getClass().getName() = " + function.getClass().getName());
    }
}

Exécutons ensemble cette classe. Le résultat est:

com.ninja_squad.lambdademo.DecompilationTest$$Lambda$1

OK. Donc le compilateur, comme pour les classes anonymes, a généré une classe avec un nom barbare. Allons voir pour confirmer:
On trouve bien la classe DecompilationTest.class. Mais pas de DecompilationTest$$Lambda$1.class.

Qu'est-ce qui se passe si on exécute le code suivant?

public class DecompilationTest {
    public static void main(String[] args) throws ClassNotFoundException {
        Class.forName("com.ninja_squad.lambdademo.DecompilationTest$$Lambda$1");
        Function<Integer, String> function = i -> i.toString();
        System.out.println("function.getClass().getName() = " + function.getClass().getName());
    }
}

ClassNotFoundException!

Et si on exécute le code suivant?

public class DecompilationTest {
    public static void main(String[] args) throws ClassNotFoundException {
        Function<Integer, String> function = i -> i.toString();
        Class.forName("com.ninja_squad.lambdademo.DecompilationTest$$Lambda$1");
        System.out.println("function.getClass().getName() = " + function.getClass().getName());
    }
}

Pas de problème. OK. Allons voir comment ça se fait:

> javap -cp . -c -p com.ninja_squad.lambdademo.DecompilationTest

public class com.ninja_squad.lambdademo.DecompilationTest {
  public com.ninja_squad.lambdademo.DecompilationTest();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.ClassNotFoundException;
    Code:
       0: invokedynamic #2,  0              // InvokeDynamic #0:lambda:()Ljava/util/function/Function;
       5: astore_1
       6: return

  private static java.lang.String lambda$0(java.lang.Integer);
    Code:
       0: aload_0
       1: invokevirtual #3                  // Method java/lang/Integer.toString:()Ljava/lang/String;
       4: areturn
}

OK. Donc le compilateur génère une méthode privée contenant l'implémentation de la fonction. A l'exécution, un invokedynamic est réalisé. Cet appel génère une classe à la volée, qui déègue à la méthode générée par le compilateur. Ne m'en demandez pas plus ;-)

Autre différence importance avec les classes anonymes: this. this désigne l'objet courant, et pas l'objet lambda. Plus besoin de OuterClass.this.foo().

Retour d'expérience:

Expérience très limitée pour le moment.
- Encore plus que pour les classes anonymes, le corps des lambda devrait être très très court. Déléguer à des méthodes si le corps fait plus d'une ou deux lignes.
- Réduit significativement le boilerplate.
- Idée géniale: toute interface fonctionnelle peut être implémentée sous forme de lambda. Ca va permettre d'utiliser les lambdas avec Guava et des tas d'autres APIs, sans attendre une quelconque évolution de Guava.
- Problème principal en ce moment: l'inférence de type. Ce serait bien de pouvoir écrire .collect(Collectors.toList()) plutôt que .collect(Collectors.<String>toList()). Travail toujours en cours pour améliorer ça.
- De nouveaux messages cryptiques du compilateur à comprendre. Pas facile facile.
- C'est une cible mouvante. On a dû réécrire nos slides 5 fois parce qu'à chaque fois qu'on revenait dessus, tout avait changé. Ca devrait se stabiliser d'ici peu.
- Manque de méthodes raccourcis. Par exemple: .toList() au lieu de .collect(Collectors.<String>toList())
- Manque cruel de javadoc. Mais ça va s'améliorer.
- Les IDEs (en tout cas IntelliJ) ne sont pas encore au point, mais le sujet est instable, donc c'est normal. Fausses inférences, signalement d'erreurs quand il n'y en a pas. Pas de signalement d'erreur quand il y en a, etc.

Le developer review va bientôt commencer. A nous d'agir. Déjà maintenant, le feedback est le bienvenu.